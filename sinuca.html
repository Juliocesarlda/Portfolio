<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SinucatroN Debug</title>
    <style>
        body { background: #000; color: #fff; font-family: sans-serif; text-align: center; margin: 0; overflow: hidden; touch-action: none; }
        #status-bar { background: #ff9800; color: #000; padding: 10px; font-weight: bold; font-size: 14px; }
        #camera-container { position: relative; width: 100vw; height: 70vh; background: #111; }
        video { width: 100%; height: 100%; object-fit: cover; }
        canvas { position: absolute; left: 0; top: 0; width: 100%; height: 100%; z-index: 999; touch-action: none; }
        .controls { padding: 20px; }
        .btn { padding: 15px 30px; background: #0ff; border: none; font-weight: bold; border-radius: 8px; }
    </style>
</head>
<body>

<div id="status-bar">CLIQUES: 0 | FASE: Calibrar Cantos</div>

<div id="camera-container">
    <video id="video" autoplay playsinline></video>
    <canvas id="canvas"></canvas>
</div>

<div class="controls">
    <button class="btn" onclick="reiniciar()">REINICIAR TUDO</button>
</div>

<script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const statusBar = document.getElementById('status-bar');

    let cantos = [];
    let bolas = [];
    let cliques = 0;

    // Iniciar Câmera
    navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } })
        .then(s => video.srcObject = s)
        .catch(e => alert("Erro câmera: " + e));

    function redimensionar() {
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
    }
    window.addEventListener('resize', redimensionar);
    redimensionar();

    // Captura de toque universal
    function handleInteraction(e) {
        e.preventDefault();
        cliques++;
        
        const rect = canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        
        const x = clientX - rect.left;
        const y = clientY - rect.top;

        if (cantos.length < 4) {
            cantos.push({x, y});
        } else {
            bolas.push({x, y});
        }
        
        atualizarStatus();
    }

    canvas.addEventListener('touchstart', handleInteraction, {passive: false});
    canvas.addEventListener('mousedown', handleInteraction);

    function atualizarStatus() {
        let fase = cantos.length < 4 ? "Calibrar Cantos" : "Marcar Bolas";
        statusBar.innerText = `CLIQUES: ${cliques} | FASE: ${fase}`;
        if (cantos.length === 4) statusBar.style.background = "#4CAF50";
    }

    function reiniciar() {
        cantos = []; bolas = []; cliques = 0;
        statusBar.style.background = "#ff9800";
        atualizarStatus();
    }

    // Loop de desenho constante
    function loop() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Desenhar mesa
        if (cantos.length > 0) {
            ctx.beginPath();
            ctx.strokeStyle = "#0f0";
            ctx.lineWidth = 3;
            ctx.moveTo(cantos[0].x, cantos[0].y);
            cantos.forEach(p => ctx.lineTo(p.x, p.y));
            if (cantos.length === 4) ctx.closePath();
            ctx.stroke();
        }

        // Desenhar bolas e tabelas
        bolas.forEach((b, i) => {
            ctx.beginPath();
            ctx.fillStyle = i === 0 ? "#fff" : "#f00";
            ctx.arc(b.x, b.y, 10, 0, Math.PI*2);
            ctx.fill();
            
            if (i === 0 && cantos.length === 4) {
                desenharSimulacao(b);
            }
        });

        requestAnimationFrame(loop);
    }

    function desenharSimulacao(branca) {
        ctx.setLineDash([5, 5]);
        for (let i = 0; i < 4; i++) {
            let p1 = cantos[i];
            let p2 = cantos[(i+1)%4];
            let mx = (p1.x + p2.x) / 2;
            let my = (p1.y + p2.y) / 2;

            // Linha branca até tabela
            ctx.beginPath();
            ctx.strokeStyle = "#0ff";
            ctx.moveTo(branca.x, branca.y);
            ctx.lineTo(mx, my);
            ctx.stroke();

            // Reflexão
            ctx.beginPath();
            ctx.strokeStyle = "#ff9800";
            ctx.moveTo(mx, my);
            ctx.lineTo(mx + (mx - branca.x), my + (my - branca.y));
            ctx.stroke();
        }
        ctx.setLineDash([]);
    }

    loop();
</script>
</body>
</html>
